// Code generated by the Code Generation Kit (CGK) using OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
//
// Copyright 2022 Edgecast Inc., Licensed under the terms of the Apache 2.0
// license. See LICENSE file in project root for terms.

/*
Customer Origins API v3

List of API of config Customer Origin.

API version: 0.5.0
Contact: portals-streaming@edgecast.com
*/

package originv3

import (
	"fmt"
	"strconv"

	"golang.org/x/exp/constraints"

	"github.com/EdgeCast/ec-sdk-go/edgecast"
	"github.com/EdgeCast/ec-sdk-go/edgecast/eclog"
	"github.com/EdgeCast/ec-sdk-go/edgecast/internal/ecauth"
	"github.com/EdgeCast/ec-sdk-go/edgecast/internal/ecclient"
)

// Service manages communication with the Customer Origins API v3 API v0.5.0
// In most cases there should be only one, shared, APIClient.
type Service struct {
	client ecclient.APIClient

	clientConfig ecclient.ClientConfig

	Logger eclog.Logger

	AdnOnly AdnOnlyClientService

	Common CommonClientService

	HttpLargeOnly HttpLargeOnlyClientService
}

// New creates a new Service
func New(config edgecast.SDKConfig) (*Service, error) {
	var authProvider ecauth.AuthorizationProvider

	authProvider, err := ecauth.NewIDSAuthorizationProvider(
		config.BaseIDSURL,
		ecauth.OAuth2Credentials(config.IDSCredentials))
	if err != nil {
		// Token authentication
		authProvider, err = ecauth.NewTokenAuthorizationProvider(config.APIToken)
		if err != nil {
			return nil, fmt.Errorf("error initializing originv3 Service: %v", err)
		}
	}

	c := ecclient.New(ecclient.ClientConfig{
		BaseAPIURL:   config.BaseAPIURL,
		UserAgent:    config.UserAgent,
		Logger:       config.Logger,
		AuthProvider: authProvider,
	})

	return &Service{
		client:        c,
		Logger:        config.Logger,
		AdnOnly:       NewAdnOnlyClientService(c, config.BaseAPIURL.String()),
		Common:        NewCommonClientService(c, config.BaseAPIURL.String()),
		HttpLargeOnly: NewHttpLargeOnlyClientService(c, config.BaseAPIURL.String()),
	}, nil
}

// request is a local representation of a request
type request struct {
	queryParams map[string]string
	pathParams  map[string]string
	headers     map[string]string
	body        interface{}
}

func newRequest() *request {
	return &request{
		queryParams: make(map[string]string),
		pathParams:  make(map[string]string),
	}
}

func numberToString[N constraints.Integer | constraints.Float](in N) string {
	return fmt.Sprintf("%v", in)
}

func boolToString(in bool) string {
	return strconv.FormatBool(in)
}
